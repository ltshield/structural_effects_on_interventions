# NOTE: This code was generated by OpenAI's ChatGPT, see prompt below.

# PROMPT USED TO GENERATE THIS CODE WITH CHATGPT
"""
This is great. Let's generate drop-in code that will allow me to set
parameters like num_nodes, delete_bias (random, degree), create the
graph and run the distribution calculations for 250 rounds for each
edge deletion until all edges in the network are deleted, and will
calculate the lambda2, k-core, lowest achievable plateau, and edge
density and plot them for each round. Make this usable with each
representative network type like small-world, complete, scale-free, and
random.
"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt


# ============================
#  Utility functions
# ============================

def gini_coefficient(x):
    """
    Compute Gini coefficient of a 1D array x (non-negative, mass-conserving).
    """
    x = np.asarray(x, dtype=float)
    if x.size == 0:
        return 0.0
    # shift if negative (shouldn't happen in this simulation)
    if np.min(x) < 0:
        x = x - np.min(x)
    if np.allclose(x, 0):
        return 0.0

    x_sorted = np.sort(x)
    n = x_sorted.size
    cum = np.cumsum(x_sorted)
    # standard Gini formula
    gini = (2.0 * np.sum((np.arange(1, n + 1) * x_sorted))) / (n * cum[-1]) - (n + 1) / n
    return gini


def build_transition_matrix(G, num_nodes):
    """
    Build a row-stochastic transition matrix P from graph G.
    If a node has degree 0, it keeps its mass (self-loop).
    """
    # Ensure consistent node ordering 0..num_nodes-1
    A = nx.to_numpy_array(G, nodelist=range(num_nodes))
    degrees = A.sum(axis=1)
    P = np.zeros_like(A)

    for i, deg in enumerate(degrees):
        if deg > 0:
            P[i, :] = A[i, :] / deg
        else:
            P[i, i] = 1.0  # isolated node keeps its mass

    return P


def compute_lambda2(G, num_nodes):
    """
    Compute algebraic connectivity λ2 of G.
    If graph has < 2 nodes or is totally edgeless, λ2 = 0.
    """
    if G.number_of_nodes() < 2 or G.number_of_edges() == 0:
        return 0.0

    L = nx.laplacian_matrix(G, nodelist=range(num_nodes)).toarray()
    eigvals = np.linalg.eigvalsh(L)
    eigvals = np.sort(eigvals)
    if len(eigvals) < 2:
        return 0.0
    return float(eigvals[1])


def compute_max_kcore(G):
    """
    Compute maximum k-core of G.
    If G has no edges, return 0.
    """
    if G.number_of_edges() == 0:
        return 0
    cores = nx.core_number(G)
    return max(cores.values()) if cores else 0


def smooth_curve(y, window=5):
    """
    Simple moving average smoothing. window=1 disables smoothing.
    """
    y = np.asarray(y, dtype=float)
    if window <= 1 or len(y) <= 2:
        return y
    pad = window // 2
    y_padded = np.pad(y, (pad, pad), mode='edge')
    kernel = np.ones(window) / window
    return np.convolve(y_padded, kernel, mode='valid')

def detect_gini_liftoff(xs, g_low, base_window=5,
                        abs_tol=0.01, rel_tol=0.05,
                        smooth_window=5):
    """
    Detect the *lift-off* point for minimum-achievable Gini.

    Idea:
      - Smooth the lower-envelope Gini curve.
      - Estimate a baseline from the first `base_window` points.
      - Define a threshold = max(baseline + abs_tol, baseline * (1 + rel_tol)).
      - Return the first x where Gini >= threshold (i.e., it has
        meaningfully lifted off from its near-zero baseline).

    xs: x-values (e.g., edge densities), 1D array
    g_low: lower-envelope Gini at each x, same shape as xs
    """
    xs = np.asarray(xs)
    g_low = np.asarray(g_low, dtype=float)

    g_smooth = smooth_curve(g_low, window=smooth_window)

    # Estimate baseline from the earliest region (where network is very connected)
    k = min(base_window, len(g_smooth))
    baseline = float(np.median(g_smooth[:k]))

    # In practice baseline will be near 0, but this keeps it generic
    threshold = max(baseline + abs_tol, baseline * (1.0 + rel_tol))

    # First index where Gini clearly lifts off
    lift_idxs = np.where(g_smooth >= threshold)[0]
    if len(lift_idxs) == 0:
        # Never clearly lifts -> treat last point as failure point
        idx = len(xs) - 1
    else:
        idx = int(lift_idxs[0])

    return xs[idx], idx, g_smooth, baseline, threshold


def detect_plateau(xs, ys, tol=0.01, smooth_window=5):
    """
    Generic plateau detector:

    Finds earliest x where ys is within `tol` of its best (minimum) future value:
        best_future[i] = min(ys_smooth[i:])
        drop[i] = ys_smooth[i] - best_future[i]
    plateau = first i where drop[i] <= tol.

    This works for curves that are mostly decreasing or flattening.
    For increasing curves you can pass -ys instead (if needed).
    """
    xs = np.asarray(xs)
    ys = np.asarray(ys, dtype=float)

    ys_smooth = smooth_curve(ys, window=smooth_window)

    # future_min[i] = min(ys_smooth[i:])
    future_min = np.minimum.accumulate(ys_smooth[::-1])[::-1]
    drop = ys_smooth - future_min

    candidates = np.where(drop <= tol)[0]
    if len(candidates) == 0:
        plateau_idx = len(xs) - 1
    else:
        plateau_idx = int(candidates[0])

    plateau_x = xs[plateau_idx]
    return plateau_x, plateau_idx, ys_smooth


def plot_curve_with_plateau(xs, ys, ys_smooth, plateau_x, plateau_idx,
                            xlabel, ylabel, title=None):
    plt.figure()
    plt.plot(xs, ys, marker='o', linestyle='-', label='Raw')
    plt.plot(xs, ys_smooth, linestyle='--', label='Smoothed')
    plt.axvline(plateau_x, linestyle=':', label=f'Plateau at {plateau_x:.3f}')
    plt.scatter([xs[plateau_idx]], [ys_smooth[plateau_idx]], zorder=5)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if title:
        plt.title(title)
    plt.legend()
    plt.tight_layout()
    plt.show()


# ============================
#  Graph generation & deletion
# ============================

def generate_graph(num_nodes, graph_type="erdos_renyi", graph_kwargs=None, seed=None):
    """
    Generate an initial graph of the requested type.

    graph_type ∈ {"complete", "erdos_renyi", "watts_strogatz", "barabasi_albert"}
    graph_kwargs depends on type:
        - "complete": {}
        - "erdos_renyi": {"p": float}
        - "watts_strogatz": {"k": int, "beta": float}
        - "barabasi_albert": {"m": int}
    """
    if graph_kwargs is None:
        graph_kwargs = {}

    if graph_type == "complete":
        G = nx.complete_graph(num_nodes)
    elif graph_type == "erdos_renyi":
        p = graph_kwargs.get("p", 0.2)
        G = nx.erdos_renyi_graph(num_nodes, p, seed=seed)
    elif graph_type == "watts_strogatz":
        k = graph_kwargs.get("k", max(2, num_nodes // 10))  # average degree
        beta = graph_kwargs.get("beta", 0.1)
        G = nx.watts_strogatz_graph(num_nodes, k, beta, seed=seed)
    elif graph_type == "barabasi_albert":
        m = graph_kwargs.get("m", max(1, num_nodes // 20))
        G = nx.barabasi_albert_graph(num_nodes, m, seed=seed)
    else:
        raise ValueError(f"Unknown graph_type: {graph_type}")

    # Ensure nodes are 0..num_nodes-1 (NetworkX usually does this already)
    return nx.relabel_nodes(G, {old: old for old in G.nodes()})


def choose_edge_to_delete(G, bias="random", rng=None):
    """
    Choose an edge to delete from G under a given bias:
        - "random": uniform random edge
        - "degree": weighted by sum of degrees of endpoints
    """
    if rng is None:
        rng = np.random.default_rng()

    edges = list(G.edges())
    if not edges:
        return None

    if bias == "random":
        idx = rng.integers(len(edges))
        return edges[idx]

    elif bias == "degree":
        deg = dict(G.degree())
        weights = np.array([deg[u] + deg[v] for u, v in edges], dtype=float)
        if np.all(weights == 0):
            idx = rng.integers(len(edges))
        else:
            probs = weights / weights.sum()
            idx = rng.choice(len(edges), p=probs)
        return edges[idx]

    else:
        raise ValueError(f"Unknown delete_bias: {bias}")


def edges_deleted_to_density(xs_deleted, num_nodes):
    """
    Convert edges_deleted -> edge density (E / E_max of complete graph).
    """
    xs_deleted = np.asarray(xs_deleted)
    E_max = num_nodes * (num_nodes - 1) / 2.0
    E_remaining = E_max - xs_deleted
    density = E_remaining / E_max
    density[density < 0] = 0.0
    return density


# ============================
#  Diffusion experiments
# ============================

def run_diffusion_experiments(P, num_runs, token_rounds, total_tokens, rng):
    """
    Run diffusion starting from random initial token distributions.

    - P: (n x n) transition matrix
    - num_runs: number of independent initializations
    - token_rounds: rounds of diffusion per run
    - total_tokens: total mass (just a scaling factor)
    - rng: np.random.Generator
    """
    n = P.shape[0]
    ginis = []

    for _ in range(num_runs):
        # Random initial distribution via Dirichlet
        x = rng.dirichlet(np.ones(n)) * total_tokens
        for _ in range(token_rounds):
            x = x @ P
        g = gini_coefficient(x)
        ginis.append(g)

    return ginis


# ============================
#  Main experiment driver
# ============================

def run_network_deletion_experiment(
        num_nodes=30,
        graph_type="erdos_renyi",
        graph_kwargs=None,
        delete_bias="random",
        num_runs_per_level=20,
        token_rounds=250,
        total_tokens=1000,
        plateau_quantile=0.10,
        gini_plateau_tol=0.01,
        lambda_plateau_tol=0.005,
        kcore_plateau_tol=0.5,
        smooth_window=5,
        seed=42
):
    """
    Full pipeline:
      - build graph
      - iteratively delete edges until none remain
      - at each deletion level:
            * compute λ2, k-core, edge density
            * run num_runs_per_level diffusions for 250 rounds
              -> Gini distribution
      - detect minimum-achievable Gini plateau
      - detect λ2 and k-core plateaus
      - plot everything vs edge density
    """
    rng = np.random.default_rng(seed)
    G = generate_graph(num_nodes, graph_type=graph_type,
                       graph_kwargs=graph_kwargs, seed=seed)

    # For indexing: edges_deleted -> metrics
    deletion_results = {}
    edges_deleted = 0

    # We want E_max based on complete graph on same node set
    E_max = num_nodes * (num_nodes - 1) // 2

    while True:
        # Build transition matrix, metrics for current graph
        P = build_transition_matrix(G, num_nodes)
        lambda2_val = compute_lambda2(G, num_nodes)
        kcore_val = compute_max_kcore(G)
        ginis = run_diffusion_experiments(P, num_runs=num_runs_per_level,
                                          token_rounds=token_rounds,
                                          total_tokens=total_tokens,
                                          rng=rng)

        # Edge density (relative to complete graph)
        E_current = G.number_of_edges()
        edge_density = E_current / E_max

        deletion_results[edges_deleted] = {
            "ginis": ginis,
            "lambda2": [lambda2_val] * num_runs_per_level,
            "k_core": [kcore_val] * num_runs_per_level,
            "edge_density": edge_density,
        }

        # Stop if there are no edges left
        if G.number_of_edges() == 0:
            break

        # Otherwise delete one edge and increment
        e = choose_edge_to_delete(G, bias=delete_bias, rng=rng)
        if e is None:
            break
        G.remove_edge(*e)
        edges_deleted += 1

    # ============================
    #  Analysis: envelopes & plateaus
    # ============================

    xs_deleted = np.array(sorted(deletion_results.keys()))
    densities = edges_deleted_to_density(xs_deleted, num_nodes)

    # Lower envelope (or quantile) for Gini
    g_low = []
    lambda_curve = []
    kcore_curve = []

    for d in xs_deleted:
        rec = deletion_results[d]
        ginis = np.array(rec["ginis"])
        if plateau_quantile is None:
            g_low.append(ginis.min())
        else:
            g_low.append(np.quantile(ginis, plateau_quantile))
        lambda_curve.append(np.max(rec["lambda2"]))  # all identical
        kcore_curve.append(np.max(rec["k_core"]))    # all identical

    g_low = np.array(g_low)
    lambda_curve = np.array(lambda_curve)
    kcore_curve = np.array(kcore_curve)

    # Gini plateau
    gini_liftoff_density, gini_idx, g_low_smooth, gini_baseline, gini_thr = detect_gini_liftoff(
        densities, g_low,
        base_window=5,
        abs_tol=gini_plateau_tol,   # reuse this as an absolute "lift" tolerance
        rel_tol=0.05,               # 5% relative lift, can tweak
        smooth_window=smooth_window
    )

    # λ2 plateau (curve mostly decreasing; same logic)
    lambda_plateau_density, lambda_idx, lambda_smooth = detect_plateau(
        densities, lambda_curve, tol=lambda_plateau_tol, smooth_window=smooth_window
    )

    # k-core plateau (integer-valued, small smoothing window)
    kcore_plateau_density, kcore_idx, kcore_smooth = detect_plateau(
        densities, kcore_curve, tol=kcore_plateau_tol, smooth_window=3
    )

    print(f"Graph type: {graph_type}, delete_bias: {delete_bias}")
    print(f"  Gini min-achievable *lift-off* density ≈ {gini_liftoff_density:.3f}")
    print(f"  λ2 plateau density ≈ {lambda_plateau_density:.3f}")
    print(f"  k-core plateau density ≈ {kcore_plateau_density:.3f}")

    # ============================
    #  Plots
    # ============================

    plot_curve_with_plateau(
        densities, g_low, g_low_smooth,
        plateau_x=gini_liftoff_density,
        plateau_idx=gini_idx,
        xlabel="Edge density (E / E_max)",
        ylabel=f"Lower-envelope Gini (q={plateau_quantile})",
        title="Minimum-achievable Gini vs edge density"
    )

    plot_curve_with_plateau(
        densities, lambda_curve, lambda_smooth,
        plateau_x=lambda_plateau_density,
        plateau_idx=lambda_idx,
        xlabel="Edge density (E / E_max)",
        ylabel="λ₂ (algebraic connectivity)",
        title="λ₂ vs edge density"
    )

    plot_curve_with_plateau(
        densities, kcore_curve, kcore_smooth,
        plateau_x=kcore_plateau_density,
        plateau_idx=kcore_idx,
        xlabel="Edge density (E / E_max)",
        ylabel="Max k-core",
        title="k-core vs edge density"
    )

    return deletion_results


# ============================
#  Example usage
# ============================

if __name__ == "__main__":
    # You can tweak these parameters and rerun to explore different topologies

    # 1) Erdos-Renyi random graph
    deletion_results_er = run_network_deletion_experiment(
        num_nodes=40,
        graph_type="erdos_renyi",
        graph_kwargs={"p": 0.3},
        delete_bias="random",
        num_runs_per_level=20,
        token_rounds=250,
        total_tokens=1000,
        plateau_quantile=0.10,
        gini_plateau_tol=0.01,
        lambda_plateau_tol=0.005,
        kcore_plateau_tol=0.5,
        smooth_window=5,
        seed=42,
    )

    # 2) Small-world (Watts-Strogatz)
    deletion_results_ws = run_network_deletion_experiment(
        num_nodes=40,
        graph_type="watts_strogatz",
        graph_kwargs={"k": 6, "beta": 0.1},
        delete_bias="degree",
        num_runs_per_level=20,
        token_rounds=250,
        seed=43,
    )

    # 3) Scale-free (Barabasi-Albert)
    deletion_results_ba = run_network_deletion_experiment(
        num_nodes=40,
        graph_type="barabasi_albert",
        graph_kwargs={"m": 2},
        delete_bias="degree",
        num_runs_per_level=20,
        token_rounds=250,
        seed=44,
    )

    # 4) Complete graph
    deletion_results_complete = run_network_deletion_experiment(
        num_nodes=20,
        graph_type="complete",
        delete_bias="random",
        num_runs_per_level=20,
        token_rounds=250,
        seed=45,
    )

"""

FINDINGS

Graph type: erdos_renyi, delete_bias: random
  Gini min-achievable *lift-off* density ≈ 0.960
  λ2 plateau density ≈ 0.754
  k-core plateau density ≈ 0.688
Graph type: watts_strogatz, delete_bias: degree
  Gini min-achievable *lift-off* density ≈ 0.991
  λ2 plateau density ≈ 0.900
  k-core plateau density ≈ 0.847
Graph type: barabasi_albert, delete_bias: degree
  Gini min-achievable *lift-off* density ≈ 0.929
  λ2 plateau density ≈ 0.969
  k-core plateau density ≈ 0.904
Graph type: complete, delete_bias: random
  Gini min-achievable *lift-off* density ≈ 0.968
  λ2 plateau density ≈ 0.105
  k-core plateau density ≈ 0.005

 ALL RANDOM
Graph type: erdos_renyi, delete_bias: random 
Gini min-achievable *lift-off* density ≈ 0.960 
λ2 plateau density ≈ 0.754 
k-core plateau density ≈ 0.688 
Graph type: watts_strogatz, delete_bias: random 
Gini min-achievable *lift-off* density ≈ 0.986 
λ2 plateau density ≈ 0.922 
k-core plateau density ≈ 0.847 
Graph type: barabasi_albert, delete_bias: random 
Gini min-achievable *lift-off* density ≈ 0.941 
λ2 plateau density ≈ 0.981 
k-core plateau density ≈ 0.904 
Graph type: complete, delete_bias: random 
Gini min-achievable *lift-off* density ≈ 0.968 
λ2 plateau density ≈ 0.105 
k-core plateau density ≈ 0.005 

 ALL DEGREE
Graph type: erdos_renyi, delete_bias: degree 
Gini min-achievable *lift-off* density ≈ 0.963 
λ2 plateau density ≈ 0.768 
k-core plateau density ≈ 0.688 
Graph type: watts_strogatz, delete_bias: degree 
Gini min-achievable *lift-off* density ≈ 0.991 
λ2 plateau density ≈ 0.900 
k-core plateau density ≈ 0.847 
Graph type: barabasi_albert, delete_bias: degree 
Gini min-achievable *lift-off* density ≈ 0.929 
λ2 plateau density ≈ 0.969 
k-core plateau density ≈ 0.904 
Graph type: complete, delete_bias: degree 
Gini min-achievable *lift-off* density ≈ 0.968 
λ2 plateau density ≈ 0.137 
k-core plateau density ≈ 0.005
"""
